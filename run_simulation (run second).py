#Transit Simulation based on Google API GTFS schedules
#By: Laure Briol with the assistance of Generative AI

#This program is designed to 'run' an agent-based simulation of transit routes. The program takes input of recommended transit route options to get from a starting point to an end point
##Formatted by the Google Directions API. This recommended transit route should already be generated by earlier steps in this transit simulation project in the specific (to_work|from_work)_YYYYMMDD_HHMM.json name scheme.

#What this program does is read a file containing directions from the Google API. The file has multiple route options (ways to get to the start/end point). This program file runs a simulation, testing each route option to see how much time it actually takes to travel along that route.
#The program runs two simulations per route option. One simulation is run where it departs immediately at the indicated time from the directions .json file (usually right on the hour), and once for the 'recommmended' departure time from Google's API.
#The 'recommended' time is there to minimize waiting at the first transit stop and catch the very first transit line, when it is scheduled to arrive. Two simulations are performed, so a comparison can be made for leaving at a set time every day versus leaving dynamically based on the future route schedule.

#This program uses Functional Programming prinnciples. This means that all the code is written as 'functions' that pre-define all the tasks which are all then called later in a 'main' section of code to run the simulation.

#here are all the sections of the code:

#import statements: These are all the required libraries needed for this simuation.

#functions -- Here are all the functions that are used in the program.

#meters_to_feet -- Convert meters to feet.

#is_within_distance -- Checks if something at coord1 is within threshold_feet of coord2.
#In the program this is used to check if a transit vehicle is within 500 feet of a transit stop.

#calculate_initial_bearing -- This is used to check the direction coord1 is relative to coord2.
#In the program this is used to figure out which general direction the destination is from the start (like the destination is 270 degrees, aka west of the starting location)
#The program uses this bearing to help figure out which direction of transit vehicle to ride (i.e. eastbound vs westbound 3A line)

#fetch_vehicle_data -- This is used to get the information about active vehicles on a route.
#In the program this is used to figure out the live location of transit vehicles. 

#get_nextrip_routes -- This is used to get the information about a given route. It convert's Google's naming convention to MetroTransit's naming convention.
#In the program this is used to figure out which 'route number' Google is talking about when it says to follow a 'route label' (i.e. the route label is 'Metro Blue Line' but the route number is '901').
#For something like route '3A', it is easy to know the route number is 3, but for 'Metro Green Line' we need to know that that route label corresponds to route number '902'

#get_available_directions -- This is used to get the directions that a route runs on.
#In the program this is also used to help figure out which direction of transit vehicle to ride.
#This function lists out the available directions to follow on a route, like 'eastbound' or 'westbound'.

#get_direction_id -- This function does the math to figure out which transit direction to follow.
#In the program this combines the bearing and available directions to figure out the direciton to ride.
#For example, the destination is ~200 degrees from the start (southwest). We want to ride route 3A, which has options of 'eastbound' and 'westbound'.
#The closeset corresponding direction to the 200 degrees southwest is 'westbound', so this function tells us that is the route direction to ride. 

#parse_original_departure_time -- This is used to read the input directions file and figure out the proposed departure time the user wanted.
#In the program, this is used for keeping track of timing of simulations relative to the initially planned hourly departure
#for example, if the filename is to_work_20241010_0600.json, this function knows the immediate departure time is 0600 on October 10, 2024.

#simulate_route -- This is the big chunk of code that performs the simulation function itself.
#In the program the simulation is essentially following the directions given by the Google API.
#reminder -- The Google API directions are made hours in advance, so they use GTFS schedule data to figure out when transit vehciles should arrive at any given stop. This means we are following GTFS schedules but Google has done the hard work of formatting data properly and adding in walking segments to the travel.
#For example, the Google API may first say to 'walk 6 minutes' to the first transit stop. So, the simulation pretends to walk there by pausing for 6 minutes.
#Once at the transit stop, the simulation figures out which transit route and direction to follow by calling the other associated functions.
#It then 'waits' at a stop, checking the live locaiton of vehicles using the NexTrip API every ~15 seconds.
#When a vehicle is close enough (within 500 ft), the simulation gets on the vehicle, and rides it to the stop that the Google API says to ride to.
#It continues to follow directions, by getting off and walking to the next transit stop (if there is a transfer) or walking to the destination.
#The simulation keeps track of timing for different sections, such as time spent walking, riding transit, waiting for transit, waiting for transfers, and total time.
#Also, when a simulation is 'scheduled' to leave (i.e. leave at 6:12 instead of immediate at 6:00), it waits the 12 minutes before starting to follow the google directions.

#save_simulation_to_csv -- This saves the results of the simulation to a csv file.
#In the program, wherever the simulation 'ends' it saves results, regardless of it is sucessful or fails. The function reports times it took for all sections of the simulation route, like anticipated total time, actual total time, and time spent on different legs of the trip

#main -- This is the code that 'starts' all the simulations. It reads the Google directions file and then starts a new simulation to follow each route.
#In the program, it figures out how many different 'route' options there are to follow at a given moment. It starts a new simulation (like building a new sim character to start travelling) for each route option and immediate vs scheduled methodology  

#imports
import requests #used to make API calls
from geopy.distance import geodesic #calculate distance between two latitude and longitude
import math
import time
import json
from datetime import datetime, timedelta #math with time
import threading #allow to run multiple simulations at once
import pytz #time zones
import re #regular expressions --> match filename to time it should be associated with
import sys
import csv #save to csv files
import os

#distance -- what is considered close enough to a bus stop/ transit stop to be considered 'arrived'
DISTANCE_THRESHOLD_FEET = 500  
CHECK_INTERVAL_SECONDS = 15    

#conversion from meters to feet
#input: meters -- distance in meters
#output: distance measured in feet
def meters_to_feet(meters):
    return meters * 3.28084

#checks if two coordinates are within a certain distance of each other
#input: coord1 -- coordinates of first location
#input: coord2 -- coordinates of second location
#input: threshold_feet -- distance to check closeness
#output: True/False. True if the two coordinates are less than threshold_feet (i.e. 500) feet away False if the two coordinates are more than 500 (threshold_feet) feet away.
def is_within_distance(coord1, coord2, threshold_feet):
    distance_meters = geodesic(coord1, coord2).meters
    distance_feet = meters_to_feet(distance_meters)
    return distance_feet <= threshold_feet, distance_feet

#calculates 'bearing' direction from a starting coordinate to an ending coordinate
#input: coord1 -- starting coordinate, we are measuring bearing relative to this location
#input: coord2 -- ending coordinate, this is the place we want to face from the starting location
#output: compass_bearing -- 0-359 degrees. 0 degrees is straight north increasing clockwise, so 90 is east, 180 is south, 270 is west. 
def calculate_initial_bearing(coord1, coord2):
    lat1 = math.radians(coord1[0])
    lat2 = math.radians(coord2[0])
    diff_long = math.radians(coord2[1] - coord1[1])

    x = math.sin(diff_long) * math.cos(lat2)
    y = math.cos(lat1) * math.sin(lat2) - (
        math.sin(lat1) * math.cos(lat2) * math.cos(diff_long)
    )
    initial_bearing = math.atan2(x, y)
    initial_bearing = math.degrees(initial_bearing)
    compass_bearing = (initial_bearing + 360) % 360
    return compass_bearing

#function to get locations of vehicles (through NexTrip API)
#input: route_id -- the route number that we care about
#output: response -- dictionary/json that contains information about all active vehciles on that route, vehicle terminals (aka 3A, 3B, etc), directions the vehicle is travelling along the route (i.e EB, WB), and live latitiude/longitude locations for each vehicle.
def fetch_vehicle_data(route_id):
    url = f'https://svc.metrotransit.org/nextrip/vehicles/{route_id}'
    headers = {'Accept': 'application/json'}
    print(f"Fetching vehicle data from URL: {url}")
    try:
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching vehicle data: {e}")
        return None

#converts Google's route naming scheme to the NexTrip API naming scheme
#input: None -- the direct conversion happens outside this function, but this function provides al lthe information to perfom conversion
#output: routes -- all available routes that the NexTrip API has
#output: route_label_to_id -- the 'route labels' (like METRO Green Line) and their associated route ID (902)
 route_label_to_id 
def get_nextrip_routes():
    url = "https://svc.metrotransit.org/nextrip/routes"
    print(f"Fetching route data from URL: {url}")
    try:
        response = requests.get(url)
        response.raise_for_status()
        routes = response.json()
        # Build a mapping from route_label to route_id
        route_label_to_id = {}
        for route in routes:
            route_label_upper = route['route_label'].upper()
            route_id = route['route_id']
            # Map the route_label_upper to route_id
            route_label_to_id[route_label_upper] = route_id
            # If route_label starts with 'Route ', also map the number
            if route_label_upper.startswith('ROUTE '):
                route_number = route_label_upper.replace('ROUTE ', '').strip()
                route_label_to_id[route_number] = route_id
        return routes, route_label_to_id
    except requests.exceptions.RequestException as e:
        print(f"Error fetching NexTrip routes: {e}")
        return [], {}

#gets the available directions that a route will travel on (like route 3 runs Eastbound and Westbound)
#input: route_id -- the numerical route ID that the NexTrip API uses to indicate that route (i.e 3 for route 3 or 3A or 3B etc. or 901 for METRO Blue Line)
#output: response -- a dictionary with the available route directions
def get_available_directions(route_id):
    url = f'https://svc.metrotransit.org/nextrip/directions/{route_id}'
    print(f"Fetching directions data from URL: {url}")
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()  # Returns a list of directions
    except requests.exceptions.RequestException as e:
        print(f"Error fetching directions for route {route_id}: {e}")
        return []

#mapping of direction names to compass bearings
DIRECTION_NAME_BEARING = {
    'northbound': 0,
    'northeastbound': 45,
    'eastbound': 90,
    'southeastbound': 135,
    'southbound': 180,
    'southwestbound': 225,
    'westbound': 270,
    'northwestbound': 315
}

#gets the direction name that our simulation wants to follow
#input: route_id -- the numerical route ID for the NexTrip API
#input: calculated_bearing -- the numerical direction that we want to travel to get to the next stop
#input: terminal -- if a route has a terminal (the 'A' part in '3A'), include that information
#output: the direction name that we would like to follow, like 'westbound' or 'eastbound' based on finding the closest available direction to the bearing we have
def get_direction_id(route_id, calculated_bearing, terminal=''):
    directions = get_available_directions(route_id)
    min_diff = 360  # Initialize with maximum possible difference
    selected_direction_id = None
    selected_direction_name = None
    for direction in directions:
        direction_name = direction['direction_name'].lower()
        if direction_name in DIRECTION_NAME_BEARING:
            direction_bearing = DIRECTION_NAME_BEARING[direction_name]
            # Compute the smallest angle difference between two bearings
            diff = abs(calculated_bearing - direction_bearing)
            diff = min(diff, 360 - diff)  # Account for circular nature
            if diff < min_diff:
                min_diff = diff
                selected_direction_id = direction['direction_id']
                selected_direction_name = direction['direction_name']
        else:
            print(f"Direction '{direction_name}' not in bearing mapping.")
    if selected_direction_id is not None:
        print(f"Selected direction '{selected_direction_name}' (ID: {selected_direction_id}) for route {route_id}")
        return selected_direction_id
    else:
        print(f"Could not find a matching direction for bearing {calculated_bearing:.2f}Â° on route {route_id}")
        return None

#find the original departure time by reading the name of the file with Gooogle Directions
#input: filename -- the file that contains the google API directions, should have a time associated with it in the format below.
#output: the time associated for departure, usually like 0600.
def parse_original_departure_time(filename):
    # Updated to handle filenames starting with 'to_work' or 'from_work'
    # Assuming filename format: '(to_work|from_work)_YYYYMMDD_HHMM.json'
    match = re.search(r'_(\d{8})_(\d{4})\.json$', filename)
    if match:
        date_part = match.group(1)  # YYYYMMDD
        time_part = match.group(2)  # HHMM
        datetime_str = f"{date_part}{time_part}"
        departure_time = datetime.strptime(datetime_str, "%Y%m%d%H%M")
        return departure_time
    else:
        print("Filename does not match the expected format '(to_work|from_work)_YYYYMMDD_HHMM.json'")
        return None


#very large function to perform the the actual simulation from origin to destination
#it reads the directions that google gives, then follows those directions in order to get to the destination
#it uses the NexTrip API to get real time locations of transit vehicles so we can accurately time how long transit vehicles take in the real world
#input: route -- this is ONE of the route options that Google Recommended, this is a list of directions to follow like walking, transit, transfer, walking 
#input: route_index -- this is which option we are looking at from the Google Route options file, 0 is the first option, 1 is the second option, and so on
#input: departure_mode -- this is either Immediate or Scheduled. Immediate means the simulation starts right when the simulation is called, Scheduled means the simulation waits until the Google Recommended start time before starting the simulation
#input: original_departure_time -- this is the 'immediate' departure time when the simulation should run. This is usually on the hour, like 0600, 0700, ... 1900.
#input: timestamp_str -- this is the current time in string format
#input: route_label_to_id -- this is the converted 'route label' to the 'route ID' that we can use in the NexTrip API.
#output: this function ends by calling the save to csv function and saves the results of the simulation timing to a csv file
def simulate_route(route, route_index, departure_mode, original_departure_time, timestamp_str, route_label_to_id):
    print(f"\nStarting simulation for Route {route_index} [{departure_mode.capitalize()} Departure]")
    leg = route['legs'][0]
    steps = leg['steps']

    # Check if all steps are WALKING
    all_walking = all(step['travel_mode'] == 'WALKING' for step in steps)

    # Extract departure time from JSON
    departure_time_info = leg.get('departure_time', {})

    if departure_time_info:
        try:
            tz = pytz.timezone(departure_time_info['time_zone'])
        except Exception as e:
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Invalid time zone '{departure_time_info['time_zone']}': {e}")
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': original_departure_time.strftime('%Y-%m-%d %H:%M:%S') if original_departure_time else None,
                'google_departure_time': None,
                'anticipated_arrival_time': None,
                'actual_arrival_time': None,
                'anticipated_travel_time_minutes': None,
                'actual_travel_time_minutes': None,
                'time_spent_walking_minutes': None,
                'time_spent_in_transit_minutes': None,
                'time_waiting_to_leave_minutes': None,
                'time_waiting_initial_transit_minutes': None,
                'time_waiting_transfers_minutes': None,
                'completed': False,
                'steps': json.dumps(steps)  # Store steps as JSON string
            }
            save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)
            return

        departure_time = datetime.fromtimestamp(departure_time_info['value'], tz)
        google_departure_time = departure_time
        total_estimated_time = timedelta(seconds=leg['duration']['value'])
        anticipated_arrival_time = departure_time + total_estimated_time
        current_time = datetime.now(tz)

        if departure_mode == 'scheduled':
            # **Localization Step Added Here**
            # Localize original_departure_time to the same timezone
            try:
                original_departure_time_aware = tz.localize(original_departure_time)
            except AttributeError:
                # If original_departure_time is already aware
                original_departure_time_aware = original_departure_time

            time_waiting_to_leave = departure_time - original_departure_time_aware
            if time_waiting_to_leave.total_seconds() > 0:
                waiting_minutes = time_waiting_to_leave.total_seconds() / 60
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Start Time: {original_departure_time_aware.strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Arrival Time: {anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Waiting to depart at {departure_time.strftime('%Y-%m-%d %H:%M:%S')}. Waiting time: {waiting_minutes:.2f} minutes.")
                time_remaining = time_waiting_to_leave.total_seconds()

                # **Adjust max_allowed_time to start from departure_time**
                # Wait until the scheduled departure time
                while time_remaining > 0:
                    sleep_time = min(CHECK_INTERVAL_SECONDS, time_remaining)
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Time remaining to depart: {str(timedelta(seconds=int(time_remaining)))}")
                    time.sleep(sleep_time)
                    time_remaining -= sleep_time
                # After waiting, set current_time to departure_time
                current_time = departure_time
            else:
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Departure time {departure_time.strftime('%Y-%m-%d %H:%M:%S')} has already passed. Starting simulation immediately.")
                waiting_minutes = 0
                # Set current_time to now
                current_time = datetime.now(tz)

            # Initialize travel timers
            time_in_travel = timedelta(seconds=0)
            max_allowed_time = total_estimated_time + timedelta(minutes=30)
            time_spent_walking = timedelta(seconds=0)  # Initialize walking time
            time_spent_in_transit = timedelta(seconds=0)  # Initialize transit time
        elif departure_mode == 'immediate':
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Start Time: {original_departure_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Arrival Time: {(datetime.now(tz) + total_estimated_time).strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Starting simulation immediately.")
            departure_time = datetime.now(tz)
            anticipated_arrival_time = departure_time + total_estimated_time
            waiting_minutes = 0
            # **Localization Step for Immediate Departure**
            # Even though it's immediate, ensure original_departure_time is aware
            try:
                original_departure_time_aware = tz.localize(original_departure_time)
            except AttributeError:
                original_departure_time_aware = original_departure_time
            # Initialize travel timers
            time_in_travel = timedelta(seconds=0)
            max_allowed_time = total_estimated_time + timedelta(minutes=30)
            current_time = departure_time
            time_spent_walking = timedelta(seconds=0)  # Initialize walking time
            time_spent_in_transit = timedelta(seconds=0)  # Initialize transit time
        else:
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Unknown departure mode. Stopping simulation.")
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': original_departure_time.strftime('%Y-%m-%d %H:%M:%S') if original_departure_time else None,
                'google_departure_time': google_departure_time.strftime('%Y-%m-%d %H:%M:%S') if google_departure_time else None,
                'anticipated_arrival_time': anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S') if anticipated_arrival_time else None,
                'actual_arrival_time': None,
                'anticipated_travel_time_minutes': round(total_estimated_time.total_seconds() / 60, 2) if total_estimated_time else None,
                'actual_travel_time_minutes': None,
                'time_spent_walking_minutes': None,
                'time_spent_in_transit_minutes': None,
                'time_waiting_to_leave_minutes': round(waiting_minutes, 2),
                'time_waiting_initial_transit_minutes': None,
                'time_waiting_transfers_minutes': None,
                'completed': False,
                'steps': json.dumps(steps)
            }
            save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)
            return

        # Initialize waiting timers
        time_waiting_initial_transit = timedelta(seconds=0)
        time_waiting_transfers = timedelta(seconds=0)

        route_completed = True  # Flag to track if the route completed

        # Variables to track if initial transit step
        is_first_transit = True

        for step in steps:
            travel_mode = step['travel_mode']
            duration_seconds = step['duration']['value']
            duration = timedelta(seconds=duration_seconds)
            instruction = step.get('html_instructions', '')
            # Remove HTML tags for cleaner output
            instruction = re.sub('<[^<]+?>', '', instruction)

            # **Adjust the time check to exclude waiting time before departure**
            if time_in_travel > max_allowed_time:
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Simulation time exceeded max allowed time. Stopping simulation.")
                route_completed = False
                break

            if travel_mode == 'WALKING':
                # Simulate walking in intervals, reporting status at each check interval
                print(f"\n[Route {route_index}][{departure_mode.capitalize()}] Walking step: {instruction}")
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Total walking time: {duration}")
                walking_time_left = duration_seconds
                while walking_time_left > 0:
                    interval = min(CHECK_INTERVAL_SECONDS, walking_time_left)
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Walking... Time left: {str(timedelta(seconds=int(walking_time_left)))}")
                    time.sleep(interval)
                    walking_time_left -= interval
                    time_in_travel += timedelta(seconds=interval)
                    time_spent_walking += timedelta(seconds=interval)  # Accumulate walking time
                    if time_in_travel > max_allowed_time:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] Simulation time exceeded max allowed time during walking. Stopping simulation.")
                        route_completed = False
                        break
                if not route_completed:
                    break
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Finished walking at {(current_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S %Z')}")
            elif travel_mode == 'TRANSIT':
                transit_details = step['transit_details']

                # Extract transit step information
                departure_stop_name = transit_details['departure_stop']['name']
                departure_stop_location = (
                    transit_details['departure_stop']['location']['lat'],
                    transit_details['departure_stop']['location']['lng']
                )
                arrival_stop_name = transit_details['arrival_stop']['name']
                arrival_stop_location = (
                    transit_details['arrival_stop']['location']['lat'],
                    transit_details['arrival_stop']['location']['lng']
                )
                line_info = transit_details['line']
                num_stops = transit_details['num_stops']

                # Get route name from Google
                route_name = line_info.get('short_name') or line_info.get('name')
                route_name_upper = route_name.upper()

                # **Extract route number and terminal**
                match = re.match(r'^(\d+)([A-Z])$', route_name_upper)
                if match:
                    route_number = match.group(1)  # e.g., "3"
                    terminal = match.group(2)      # e.g., "A"
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Extracted route number '{route_number}' and terminal '{terminal}' from route name '{route_name}'.")
                else:
                    route_number = route_name_upper
                    terminal = ''
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Route name '{route_name}' does not have a terminal.")

                # Use route_number to get route_id
                route_id = route_label_to_id.get(route_number)
                if not route_id:
                    # Try matching with the full route_name_upper
                    route_id = route_label_to_id.get(route_name_upper)
                if not route_id:
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Route '{route_name}' not found in NexTrip data.")
                    continue

                # Calculate bearing between departure and arrival stops
                bearing = calculate_initial_bearing(departure_stop_location, arrival_stop_location)
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Calculated bearing from departure to arrival: {bearing:.2f} degrees")

                # Get direction ID based on calculated bearing and terminal
                direction_id = get_direction_id(route_id, bearing, terminal)
                if direction_id is None:
                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Could not determine direction ID based on bearing {bearing:.2f} degrees on route {route_id}")
                    continue

                print(f"\n[Route {route_index}][{departure_mode.capitalize()}] Transit step: {instruction}")
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Waiting for the next vehicle on Route ID {route_id} at stop '{departure_stop_name}'...")

                vehicle_arrived = False
                tracked_vehicle = None
                waiting_start_time = None
                waiting_minutes_current = 0

                while not vehicle_arrived:
                    if time_in_travel > max_allowed_time:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] Simulation time exceeded max allowed time while waiting for vehicle. Stopping simulation.")
                        route_completed = False
                        break

                    vehicles = fetch_vehicle_data(route_id)
                    if not vehicles:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] No vehicle data available. Retrying...")
                        time.sleep(CHECK_INTERVAL_SECONDS)
                        time_in_travel += timedelta(seconds=CHECK_INTERVAL_SECONDS)
                        continue

                    vehicle_arrived = False
                    for vehicle in vehicles:
                        # Check if vehicle matches the direction
                        vehicle_direction_id = vehicle.get('direction_id')
                        if vehicle_direction_id != direction_id:
                            continue  # Skip vehicles not matching the direction

                        # Get vehicle's current location
                        vehicle_location = (vehicle['latitude'], vehicle['longitude'])

                        # Check if vehicle is within distance threshold of the departure stop
                        within_distance, distance_feet = is_within_distance(
                            vehicle_location,
                            departure_stop_location,
                            DISTANCE_THRESHOLD_FEET
                        )

                        if within_distance:
                            print(f"[Route {route_index}][{departure_mode.capitalize()}] Vehicle {vehicle.get('trip_id')} has arrived at the departure stop at {(current_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S %Z')}.")
                            vehicle_arrived = True
                            tracked_vehicle = vehicle  # Store the vehicle to track during the ride
                            tracked_trip_id = vehicle.get('trip_id')
                            # Calculate waiting time for initial transit or transfers
                            if waiting_start_time is not None:
                                waiting_duration = time_in_travel - waiting_start_time
                                if is_first_transit:
                                    time_waiting_initial_transit += waiting_duration
                                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Waiting time for initial transit updated by {waiting_duration.total_seconds() / 60:.2f} minutes.")
                                else:
                                    time_waiting_transfers += waiting_duration
                                    print(f"[Route {route_index}][{departure_mode.capitalize()}] Waiting time for transfer updated by {waiting_duration.total_seconds() / 60:.2f} minutes.")
                            break  # Exit the loop once the vehicle has arrived
                        else:
                            print(f"[Route {route_index}][{departure_mode.capitalize()}] Vehicle {vehicle.get('trip_id')} is {distance_feet:.2f} feet away from the departure stop.")

                    if not vehicle_arrived:
                        if waiting_start_time is None:
                            waiting_start_time = time_in_travel
                        else:
                            waiting_minutes_current = (time_in_travel - waiting_start_time).total_seconds() / 60
                            print(f"[Route {route_index}][{departure_mode.capitalize()}] Currently waiting for vehicle. Time waited: {waiting_minutes_current:.2f} minutes.")
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] No vehicle has arrived at stop '{departure_stop_name}'. Checking again in {CHECK_INTERVAL_SECONDS} seconds...")
                        time.sleep(CHECK_INTERVAL_SECONDS)
                        time_in_travel += timedelta(seconds=CHECK_INTERVAL_SECONDS)

                if not vehicle_arrived:
                    # Simulation did not complete within allowed time
                    route_completed = False
                    break  # Exit the step loop

                # **Start tracking the specific vehicle during the transit ride**
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Riding the vehicle to stop '{arrival_stop_name}' (Trip ID: {tracked_trip_id})...")
                in_transit = True

                while in_transit:
                    if time_in_travel > max_allowed_time:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] Simulation time exceeded max allowed time during transit ride. Stopping simulation.")
                        route_completed = False
                        break

                    # Fetch vehicle data
                    vehicles = fetch_vehicle_data(route_id)
                    if not vehicles:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] No vehicle data available during transit. Retrying...")
                        time.sleep(CHECK_INTERVAL_SECONDS)
                        time_in_travel += timedelta(seconds=CHECK_INTERVAL_SECONDS)
                        time_spent_in_transit += timedelta(seconds=CHECK_INTERVAL_SECONDS)
                        continue

                    tracked_vehicle_found = False
                    for vehicle in vehicles:
                        if vehicle.get('trip_id') == tracked_trip_id:
                            tracked_vehicle_found = True
                            vehicle_location = (vehicle['latitude'], vehicle['longitude'])
                            # Check if vehicle is within distance threshold of the arrival stop
                            within_distance, distance_feet = is_within_distance(
                                vehicle_location,
                                arrival_stop_location,
                                DISTANCE_THRESHOLD_FEET
                            )
                            if within_distance:
                                print(f"[Route {route_index}][{departure_mode.capitalize()}] Vehicle {vehicle.get('trip_id')} has arrived at the arrival stop '{arrival_stop_name}' at {(current_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S %Z')}.")
                                in_transit = False  # Transit ride is complete
                                break
                            else:
                                print(f"[Route {route_index}][{departure_mode.capitalize()}] Vehicle {vehicle.get('trip_id')} is {distance_feet:.2f} feet away from the arrival stop.")
                            break  # Exit the vehicle loop once the tracked vehicle is found
                    if not tracked_vehicle_found:
                        print(f"[Route {route_index}][{departure_mode.capitalize()}] Tracked vehicle (Trip ID: {tracked_trip_id}) not found. Retrying...")
                    # Wait before checking again
                    time.sleep(CHECK_INTERVAL_SECONDS)
                    time_in_travel += timedelta(seconds=CHECK_INTERVAL_SECONDS)
                    time_spent_in_transit += timedelta(seconds=CHECK_INTERVAL_SECONDS)

                if not route_completed or in_transit:
                    break  # Exit the step loop if simulation failed

                print(f"[Route {route_index}][{departure_mode.capitalize()}] Finished transit ride at {(current_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S %Z')}")

                is_first_transit = False  # Subsequent transit steps are transfers

            else:
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Unknown travel mode '{travel_mode}'. Skipping step.")

            if not route_completed:
                break  # Exit the step loop if simulation failed

        # After all steps
        if route_completed:
            # Calculate actual arrival time
            actual_arrival_time = current_time + time_in_travel
            actual_travel_time = time_in_travel
            actual_travel_time_minutes = round(actual_travel_time.total_seconds() / 60, 2)

            # Calculate total waiting times
            time_waiting_to_leave_minutes = round(waiting_minutes, 2)
            time_waiting_initial_transit_minutes = round(time_waiting_initial_transit.total_seconds() / 60, 2)
            time_waiting_transfers_minutes = round(time_waiting_transfers.total_seconds() / 60, 2)

            # Compile simulation result
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': original_departure_time_aware.strftime('%Y-%m-%d %H:%M:%S'),
                'google_departure_time': google_departure_time.strftime('%Y-%m-%d %H:%M:%S'),
                'anticipated_arrival_time': anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S'),
                'actual_arrival_time': actual_arrival_time.strftime('%Y-%m-%d %H:%M:%S'),
                'anticipated_travel_time_minutes': round(total_estimated_time.total_seconds() / 60, 2),
                'actual_travel_time_minutes': actual_travel_time_minutes,
                'time_spent_walking_minutes': round(time_spent_walking.total_seconds() / 60, 2),
                'time_spent_in_transit_minutes': round(time_spent_in_transit.total_seconds() / 60, 2),
                'time_waiting_to_leave_minutes': time_waiting_to_leave_minutes,
                'time_waiting_initial_transit_minutes': time_waiting_initial_transit_minutes,
                'time_waiting_transfers_minutes': time_waiting_transfers_minutes,
                'completed': route_completed,
                'steps': json.dumps(steps)  # Store steps as JSON string
            }
        else:
            # Simulation did not complete successfully
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': original_departure_time_aware.strftime('%Y-%m-%d %H:%M:%S'),
                'google_departure_time': google_departure_time.strftime('%Y-%m-%d %H:%M:%S'),
                'anticipated_arrival_time': anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S'),
                'actual_arrival_time': None,
                'anticipated_travel_time_minutes': round(total_estimated_time.total_seconds() / 60, 2),
                'actual_travel_time_minutes': None,
                'time_spent_walking_minutes': round(time_spent_walking.total_seconds() / 60, 2),
                'time_spent_in_transit_minutes': round(time_spent_in_transit.total_seconds() / 60, 2),
                'time_waiting_to_leave_minutes': round(waiting_minutes, 2),
                'time_waiting_initial_transit_minutes': round(time_waiting_initial_transit.total_seconds() / 60, 2),
                'time_waiting_transfers_minutes': round(time_waiting_transfers.total_seconds() / 60, 2),
                'completed': False,
                'steps': json.dumps(steps)
            }

        # Save simulation result to CSV
        save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)

    else:
        # **Handling Walking-Only Routes**
        if all_walking:
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Route consists only of walking steps. Proceeding with walking simulation.")
            # Localize original_departure_time to a default timezone or system timezone
            # Here, we'll assume UTC if no timezone info is available
            try:
                tz = pytz.timezone('UTC')  # Default to UTC or choose appropriate timezone
                original_departure_time_aware = tz.localize(original_departure_time)
            except Exception as e:
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Error setting timezone: {e}")
                simulation_result = {
                    'route_index': route_index,
                    'departure_mode': departure_mode,
                    'original_departure_time': original_departure_time.strftime('%Y-%m-%d %H:%M:%S') if original_departure_time else None,
                    'google_departure_time': None,
                    'anticipated_arrival_time': None,
                    'actual_arrival_time': None,
                    'anticipated_travel_time_minutes': None,
                    'actual_travel_time_minutes': None,
                    'time_spent_walking_minutes': None,
                    'time_spent_in_transit_minutes': None,
                    'time_waiting_to_leave_minutes': None,
                    'time_waiting_initial_transit_minutes': None,
                    'time_waiting_transfers_minutes': None,
                    'completed': False,
                    'steps': json.dumps(steps)
                }
                save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)
                return

            departure_time = original_departure_time_aware
            total_walking_duration = timedelta()

            # Calculate total walking duration
            for step in steps:
                if step['travel_mode'] == 'WALKING':
                    total_walking_duration += timedelta(seconds=step['duration']['value'])

            anticipated_arrival_time = departure_time + total_walking_duration
            actual_arrival_time = departure_time + total_walking_duration  # Assuming no delays
            actual_travel_time_minutes = round(total_walking_duration.total_seconds() / 60, 2)

            print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Start Time: {departure_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Scheduled Arrival Time: {anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"[Route {route_index}][{departure_mode.capitalize()}] Starting walking simulation immediately.")

            # Initialize variables for walking simulation
            walking_time_left = total_walking_duration.total_seconds()
            time_in_travel = timedelta(seconds=0)
            time_spent_walking = timedelta(seconds=0)  # Initialize walking time

            # Simulate walking steps by sleeping for total walking duration in intervals
            while walking_time_left > 0:
                interval = min(CHECK_INTERVAL_SECONDS, walking_time_left)
                print(f"[Route {route_index}][{departure_mode.capitalize()}] Walking... Time left: {str(timedelta(seconds=int(walking_time_left)))}")
                time.sleep(interval)
                walking_time_left -= interval
                time_in_travel += timedelta(seconds=interval)
                time_spent_walking += timedelta(seconds=interval)  # Accumulate walking time

            print(f"[Route {route_index}][{departure_mode.capitalize()}] Finished walking at {(departure_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S %Z')}")

            # Compile simulation result for walking-only route
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': departure_time.strftime('%Y-%m-%d %H:%M:%S'),
                'google_departure_time': None,
                'anticipated_arrival_time': anticipated_arrival_time.strftime('%Y-%m-%d %H:%M:%S'),
                'actual_arrival_time': (departure_time + time_in_travel).strftime('%Y-%m-%d %H:%M:%S'),
                'anticipated_travel_time_minutes': round(total_walking_duration.total_seconds() / 60, 2),
                'actual_travel_time_minutes': actual_travel_time_minutes,
                'time_spent_walking_minutes': round(time_spent_walking.total_seconds() / 60, 2),
                'time_spent_in_transit_minutes': 0.0,
                'time_waiting_to_leave_minutes': 0.0,
                'time_waiting_initial_transit_minutes': 0.0,
                'time_waiting_transfers_minutes': 0.0,
                'completed': True,
                'steps': json.dumps(steps)
            }

            # Save simulation result to CSV
            save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)
            return
        else:
            print(f"[Route {route_index}][{departure_mode.capitalize()}] No departure_time information available and not all steps are walking. Stopping simulation.")
            simulation_result = {
                'route_index': route_index,
                'departure_mode': departure_mode,
                'original_departure_time': original_departure_time.strftime('%Y-%m-%d %H:%M:%S') if original_departure_time else None,
                'google_departure_time': None,
                'anticipated_arrival_time': None,
                'actual_arrival_time': None,
                'anticipated_travel_time_minutes': None,
                'actual_travel_time_minutes': None,
                'time_spent_walking_minutes': None,
                'time_spent_in_transit_minutes': None,
                'time_waiting_to_leave_minutes': None,
                'time_waiting_initial_transit_minutes': None,
                'time_waiting_transfers_minutes': None,
                'completed': False,
                'steps': json.dumps(steps)  # Store steps as JSON string
            }
            save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str)
            return

#this saves simulation results to a csv file
#input: simulation_result -- True/False this tells if the simulation was sucessful in completing or not. Usually this would fail if the simulation takes too long to run
#input: original_departure_time -- this is the original departure time, usually on the hour
#input: route_index -- this is the route option given by the google API
#input: departure_mode -- this is 'Immediate' or 'Scheduled' to define how the simulation was run
#input: timestamp_str -- this is all the timings that the simulation took, such as walking, transit, and total time spent in travel.
#output: a csv file with one row, containing all this information
def save_simulation_to_csv(simulation_result, original_departure_time, route_index, departure_mode, timestamp_str):
    # Ensure output directory exists
    output_dir = 'simulation_outputs'
    os.makedirs(output_dir, exist_ok=True)

    # Construct unique CSV filename
    csv_filename = f"simulation_results_{timestamp_str}_route{route_index}_{departure_mode}.csv"
    csv_path = os.path.join(output_dir, csv_filename)

    # Define CSV fieldnames
    fieldnames = [
        'route_index',
        'departure_mode',
        'original_departure_time',
        'google_departure_time',
        'anticipated_arrival_time',
        'actual_arrival_time',
        'anticipated_travel_time_minutes',
        'actual_travel_time_minutes',
        'time_spent_walking_minutes',    # Added field for walking time
        'time_spent_in_transit_minutes', # Added field for transit time
        'time_waiting_to_leave_minutes',
        'time_waiting_initial_transit_minutes',
        'time_waiting_transfers_minutes',
        'completed',
        'steps'
    ]

    # Write to CSV
    try:
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerow(simulation_result)
        print(f"Simulation result saved to '{csv_path}'.")
    except Exception as e:
        print(f"Error writing to CSV file '{csv_path}': {e}")

#main function to read in the file and 'start' running all the simulations as their own little tasks.
#input: filename -- this is the file that we want to read, containing Google API route options
#output: nothing -- all the functions are called in the file and this only gets things started to run
def main(filename=None):
    print(f"DISTANCE_THRESHOLD_FEET is set to {DISTANCE_THRESHOLD_FEET} feet.")
    print(f"CHECK_INTERVAL_SECONDS is set to {CHECK_INTERVAL_SECONDS} seconds.\n")

    # If filename is not provided or invalid, prompt the user
    while not filename:
        filename = input("Please enter the directions JSON filename (e.g., 'to_work_20241010_1525.json'): ").strip()
        if not os.path.isfile(filename):
            print(f"Error: File '{filename}' not found. Please try again.")
            filename = None

    # Parse original departure time from filename
    original_departure_time = parse_original_departure_time(filename)
    if original_departure_time is None:
        print("Exiting due to invalid filename format.")
        return

    # Extract timestamp string for filename inclusion
    match = re.search(r'_(\d{8})_(\d{4})\.json$', filename)
    if match:
        date_part = match.group(1)  # YYYYMMDD
        time_part = match.group(2)  # HHMM
        timestamp_str = f"{date_part}_{time_part}"
    else:
        print("Unable to extract timestamp from filename. Exiting.")
        return

    # Load Google Directions API response
    try:
        with open(filename, 'r') as file:
            directions = json.load(file)
    except FileNotFoundError:
        print(f"Error: '{filename}' file not found.")
        return
    except json.JSONDecodeError:
        print(f"Error: '{filename}' contains invalid JSON.")
        return

    # Fetch NexTrip routes and build route_label to route_id mapping
    nextrip_routes, route_label_to_id = get_nextrip_routes()
    if not nextrip_routes:
        print("Failed to fetch NexTrip routes. Exiting.")
        return

    # Extract routes
    routes = directions.get('routes', [])
    if not routes:
        print("No routes found in Google Directions API response.")
        return

    # Print all routes, their estimated times, and steps before starting simulations
    print("\nRoutes to be simulated and their estimated travel times:")
    for idx, route in enumerate(routes):
        leg = route['legs'][0]
        duration_text = leg['duration']['text']
        print(f"\nRoute {idx}: Estimated travel time - {duration_text}")
        print(f"Route {idx} steps:")
        steps = leg['steps']
        for step_num, step in enumerate(steps):
            travel_mode = step['travel_mode']
            step_duration_text = step['duration']['text']
            instruction = step.get('html_instructions', '')
            # Remove HTML tags for cleaner output
            instruction = re.sub('<[^<]+?>', '', instruction)

            if travel_mode == 'TRANSIT':
                # Extract route number or name
                transit_details = step.get('transit_details', {})
                line_info = transit_details.get('line', {})
                route_number = line_info.get('short_name') or line_info.get('name') or 'N/A'
                instruction += f" (Route {route_number})"

            print(f"  Step {step_num + 1}: {travel_mode} for {step_duration_text} - {instruction}")
    print("\nStarting simulations...\n")

    threads = []
    for idx, route in enumerate(routes):
        # Scheduled Departure Simulation
        t_scheduled = threading.Thread(target=simulate_route, args=(route, idx, 'scheduled', original_departure_time, timestamp_str, route_label_to_id))
        threads.append(t_scheduled)
        t_scheduled.start()

        # Immediate Departure Simulation
        t_immediate = threading.Thread(target=simulate_route, args=(route, idx, 'immediate', original_departure_time, timestamp_str, route_label_to_id))
        threads.append(t_immediate)
        t_immediate.start()

    # Wait for all threads to complete
    for t in threads:
        t.join()

    print("\nAll simulations complete.\n")
    print("Each simulation's results have been saved to their respective CSV files in the 'simulation_outputs' directory.\n")

if __name__ == "__main__":
    # Check if filename is provided via command-line arguments
    if len(sys.argv) > 1:
        input_filename = sys.argv[1]
        if not os.path.isfile(input_filename):
            print(f"Error: File '{input_filename}' not found.")
            input_filename = None
    else:
        input_filename = None

    main(input_filename)
